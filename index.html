<!doctype html>
<html lang="en">

<head>
<script type="text/javascript">
	WebFontConfig = {
		 google: { families: [ 'Source+Sans+Pro:400,700:latin' ] }
	};
	(function() {
		var wf = document.createElement('script');
		wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
			'://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
		wf.type = 'text/javascript';
		wf.async = 'true';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(wf, s);
	})();
</script>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width">
	<title>Home | semicolon.works</title>
	<link rel="stylesheet" href="/css/main.css">
</head>
<body>
	<h1>semicolon.works</h1>
			<article class="post-single">
				<h2 class="article-title"><a href="/articles/supporting-multiple-build-tools">Supporting multiple build tools</a></h2>
				<div class="article-date">08-04-2015</div>
		<p>At Demandware, I work on a reference application &#8211; sort of like a starting point for developers to use in building a e-commerce web application. Its purpose is to cut down on implementation time. One of the demands for this project is to create something that can be used and liked many developers with varied backgrounds, experiences and opinions.</p>
		<p>When I decided to introduce a much needed modern build tool into the project (for things like compiling Sass to CSS, bundling browserify modules, running tests etc.), I was met with a choice of whether to use grunt or gulp.</p>
		<p>While grunt has grown to be quite popular among many developers (the ones at my company included), there are limits to its approach that make it clunky to work with (a declarative API in defining tasks, different tasks interact with each other through the file system). Gulp has gained quite a bit of popularity due to its approach of using stream and a programmatic API. Admittedly, gulp is a lot more fun for me to use and maintain.</p>
		<p>However, this was not a straightforward choice as many people were voicing concern against going after the &#8220;latest and greatest&#8221; tool, and wanting to keep the technology stack consistent within the enterprise. While this is not an argument I agree with, I could appreciate and respect the intention.</p>
		<p>Instead of plunging into a heated debate with other engineers over what is a better build tool, I decided to support both for the project. In retrospect, this decision has turned out to be a wise one.</p>
		<p>It makes the idea of introducing a build tool that much easier to sell. I have the ability of pitch it by saying something like &#8220;you can use either gulp or grunt, and they both would work the same&#8221;. It appeals to three groups &#8211; the ones who have spent time and effort learning grunt and feel comfortable in it, the ones who keep more up to date with bleeding edge, and also the ones who do not know either but want to learn/ use one.</p>
		<p>Furthermore, it sets the expectation that while a build tool is needed and important in modern web development, the project is not tied to a single tool. This opens up room for experimentation with new workflow and tooling options. If a new tool is available, it should be adopted and played with, regardless of whether it is a grunt or gulp tool. This also means that a completely new build tool can be experimented with as well, be it broccoli, npm run-scripts, or (gasp!) even make. We promise that the interface and tasks should be <strong>eventually</strong> consistent across these build tools, but they do not have to be on parity at any single time. We do try however to make the most basic tasks such as Sass and browserify to be available across all build tools.</p>
		<p>While this setup makes a lot of sense for our project, it might not be as practical or wise for others, especially those that are used/ maintained by a small group of people whose preferences/ opinions are more closely aligned. Having said that, I find it quite liberating and welcoming to newcomers to a project to have different build tools available. It is sort of like a quiet nod to all the three groups I mentioned above, making sure that none of them feels particularly left out. I have come to strongly believe that in order to make a project successful, it is usually helpful to make contributors, especially newcomers, feel welcomed and comfortable.</p>
		
			</article><!-- .post-single -->
			<article class="post-single">
				<h2 class="article-title"><a href="/articles/introducing-tobiko">Introducing Tobiko</a></h2>
				<div class="article-date">08-04-2015</div>
		<p>About a year and a half ago, amidst the hype of static sites, I attempted to convert my WordPress blog over to a static blog. The advantages were clear to me as a developer: much faster performance, authoring in markdown, source-controlled content out of the box, easy and free hosting with Github Pages, and the list goes on. This was the motivation for <a href="https://github.com/tnguyen14/tobiko">tobiko</a>, a Grunt-based static site generator &#8211; a tool I wrote that I thought would be useful for other developers out there.</p>
		<h3>Existing static site generators</h3>
		<p>The path to tobiko where it is today was not always straight forward however. I did not want to reinvent the wheels initially, and tried out a few different static site generators out there.</p>
		<p>I began with the obvious choice &#8211; Octopress powered by Jekyll. There was (and still is) a lot of enthusiasm about Jekyll in the open source community, and I believe that is so for good reasons. However, at this time period, I started to write a lot more JavaScript in the browser as well as node, and for some reason Ruby and its tool chain never really clicked for me. I had a lot of issues setting Octopress up and deploying properly, most likely due to my own shortcoming, despite having taken an intro to Ruby course on Codeacademy a few months prior.</p>
		<p>As node was already a huge and growing community back then, there were a few contenders of static site generator written in node as well. Most notably was <a href="http://wintersmith.io/">wintersmith</a>, which I thought was very cool. I tried it out and even wrote <a href="https://github.com/tnguyen14/wintersmith-handlebars">a plugin</a> for it. Nonetheless, I ended up parting ways with wintersmith as well. The tool was authored mostly in Coffeescript, which did not appeal to me, and the whole plugin architecture seemed confusing.</p>
		<h3>Grunt &#8211; a proven build tool</h3>
		<p>At the same time, Grunt was quickly becoming very popular as a mainstream build tool with a great community around it. And I thought the whole idea of a static site generator fits in very well with a build tool ecosystem. So I created <a href="https://github.com/tnguyen14/tobiko">tobiko</a> &#8211; a Grunt-based static site generator.</p>
		<h3>Main features</h3>
		<p>I wanted tobiko to be based on a stack that I would like to work with. Here are a few highlights:</p>
		<ul>
		<li>tobiko itself is a glorified grunt plugin, which features 2 main task &#8211; parsing content and generating html pages.</li>
		<li>Content can be written in either Markdown (with YAML frontmatter) or JSON.</li>
		<li>Templates are written in Handlebars by default.</li>
		<li>Styles are written in SCSS by default.</li>
		<li>JavaScript uses RequireJS to support AMD syntax.</li>
		<li>Site and project configurations are stored in JSON files that can be overwritten based on the environment (<code>dev</code> vs <code>prod</code>).</li>
		<li>Content can be nested indefinitely in the traditional file system. HTML pages reflect that nesting structure. That path however can be overwritten as desired.</li>
		<li>Pagination and archives.</li>
		<li>Image compression with responsive image support by generating multiple image resolutions on build.</li>
		<li>Deployment to Github Pages or any static server with <code>rsync</code>.</li>
		</ul>
		<h3>Yeoman generator</h3>
		<p>If these features are enough to intrigue you, I&#8217;d encourage you to try tobiko out. I&#8217;ve also written a <a href="https://github.com/tnguyen14/generator-tobiko">Yeoman generator</a> for tobiko, so that you can set up all the directory structure and grunt tasks within a minute or two. The whole idea is to scaffold and deploy a simple static site within a matter of minutes.</p>
		<h3>Roadmap</h3>
		<p>I have used tobiko to create a few sites so far with very satisfying results. I think that something like tobiko can be very useful for a simple business site, personal blog or even a style guide for larger projects. It is definitely meant for developers who know their way around code and JavaScript, and who enjoy writing content in Markdown.</p>
		<p>In the course of using tobiko, I have found a few areas for improvement as well as possible ways to expand the project. Here are some ideas of what I&#8217;d like to do with it next (without selling too much vaporware):</p>
		<ul>
		<li>Create a gulp-based version. File systems are great, but streams can speed up the build process many times over.</li>
		<li>Add more tests to make the tasks more stable.</li>
		<li>Support for browserify/ CommonJS syntax for JavaScript.</li>
		<li>Support for other templating engines.</li>
		</ul>
		<p>If you take a look at tobiko (which is by itself pretty simple) and think you can help out with these items, please feel free to file an issue or send a pull request.</p>
		<p>Thanks very much for reading this far, and if I&#8217;ve got you somewhat convinced, definitely give <a href="https://github.com/tnguyen14/tobiko">tobiko</a> and <a href="https://github.com/tnguyen14/generator-tobiko">generator-tobiko</a> a try!</p>
		
			</article><!-- .post-single -->
			<article class="post-single">
				<h2 class="article-title"><a href="/articles/aliasify-config">Use aliasify to include configurations in your web application</a></h2>
				<div class="article-date">08-04-2015</div>
		<p>As I build more web applications, one problem that I keep running into is how to include application configurations into the application source code.</p>
		<h3>What do I mean by configurations?</h3>
		<p>They include application-specific settings such as the application name, API URL, debug mode etc. These are metadata to the application, similar to the metadata contained in <code>package.json</code> for a Node module.</p>
		<p>As I develop most of my applications locally, some of these settings will differ when the application is served on localhost versus when served in production. For eg., I usualy use a staging API server for local development and then a production server for deployment.</p>
		<h3>I could certainly hardcode these settings into the source code right?</h3>
		<p>The fact that I need 2 (or more) environment-specific versions of these settings make them difficult to be hardcoded. Furthermore, as a developer, I feel a little &#8220;dirty&#8221; when I hardcode these settings. Ideally, they should be declared in a JSON file somewhere, just like <code>package.json</code>.</p>
		<h3>There must be other solutions out there!</h3>
		<p>Surprisingly, there isn&#8217;t a good straight forward solution out there, as far as I know (if you know of one, please leave a comment). Here are a few worth mentioning:</p>
		<p>One can follow the approach outlined by Addy Osmani in <a href="http://addyosmani.com/blog/environment-specific-builds-with-grunt-gulp-or-broccoli/">making environment-specific builds with build tools</a> and use some sort of string replacement plugin. However, this will introduce some &#8216;not-so-pretty&#8217; delimiters in the codebase, such as <code>@@foo</code> used by grunt-replace.</p>
		<p>Henrik Joreteg&#8217;s <a href="https://github.com/HenrikJoreteg/clientconfig">clientconfig</a> is another elegant solution and very close to what I have in mind, however it relies on a server component to set all the configurations in a cookie. This is not a hard requirement, but is not feasible for a static site running on a simple file server (such as Github Pages) like this blog.</p>
		<h3>Another attempt at solving this problem</h3>
		<p>If you are using <a href="https://github.com/substack/node-browserify">browserify</a> to bundle your JavaScript code, this might be a good solution for you.</p>
		<p>Using <a href="https://github.com/benbria/aliasify">aliasify</a>, you can require your config, which is declared in a <code>config.json</code> file like this:</p>
		<pre><code class="language-javascript">{
		  "API_URL": "http://example_server.com/api",
		  "env": "development"
		}
		</code></pre>
		<pre><code class="language-javascript">var config = require('config');
		
		console.log(config.API_URL); //prints out API_URL
		if (config.env === 'development') {
		  // do something specifically in development mode
		}
		</code></pre>
		<p>To declare this transformation, you can add the following section to <code>package.json</code>:</p>
		<pre><code class="language-javascript">{
		  "aliasify": {
		    aliases: {
		      "config": "./config.json"
		    }
		  }
		}
		</code></pre>
		<p>Pretty simple, right?</p>
		<h3>Environment-specific configs</h3>
		<p>We can make this even better, by allowing for environment-sepcific configs. To do that, I recommend using a build tool like grunt or gulp. I am sure there is probably a way to do it with just the simple browserify command line interface, but using browserify programmatically makes things a lot easier.</p>
		<p>Here&#8217;s an example of how I am using this in a recent project:</p>
		<pre><code class="language-javascript">// gulpfile.js
		
		// enable development mode
		var dev = false;
		gulp.task('enable-dev-mode', function () {
		  dev = true;
		});
		
		gulp.task('scripts', function () {
		  // set up browserify bundle in here
		  // see https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-uglify-sourcemap.md
		
		  // aliasify config
		  var aliasify = require('aliasify').configure({
		  aliases: {
		    'config': './config' + (dev ? '.dev' : '') + '.json'
		  },
		  configDir: __dirname
		  })
		  bundler.transform(aliasify);
		});
		</code></pre>
		<p>In this approach, aliasify will automatically use <code>config.dev.json</code> for development environment and <code>config.json</code> for production one.</p>
		<p>A similar approach could be taken when using <a href="https://github.com/jmreidy/grunt-browserify">grunt-browserify</a>. In fact, it is probably easier to do environment-specific stuff with grunt due to its ability to declare a task target.</p>
		<p>There you have it, a simple approach to accessing environment configuations in your project that is made possible by browserify.</p>
		<h3>What&#8217;s bad, what&#8217;s good, what could be better?</h3>
		<p>This solution&#8217;s downside is relying on browserify (and possibly a build system), which might not be applicable for an older project. If you use RequireJS/AMD, I imagine it&#8217;d be similarly easy to include such a config file using the <a href="https://github.com/millermedeiros/requirejs-plugins">JSON plugin</a>.</p>
		<p>One possible improvement to this solution is allowing the ability to cascade configs across environment. For example:</p>
		<p>In <code>config.json</code></p>
		<pre><code class="language-javascript">{
		  "appName": "FooBar",
		  "apiUrl": "http://foobar.com/api"
		}
		</code></pre>
		<p>And then <code>config.dev.json</code> just &#8220;extend&#8221; it without redeclaring common configs:</p>
		<pre><code class="language-javascript">{
		  "apiUrl": "http://localhost:3000"
		}
		</code></pre>
		<p>This is currently not possible with using aliasify. I have implemented a similar version of this as a grunt task for <a href="https://github.com/tnguyen14/tobiko#configjson">tobiko</a>, but it&#8217;s not polished enough to be used by others yet. I will update this space if and when this becomes available.</p>
		
			</article><!-- .post-single -->
			<article class="post-single">
				<h2 class="article-title"><a href="/articles/handlebars-templates-with-backbone-grunt-and-requirejs">Handlebars templates with Backbone, grunt.js and RequireJS</a></h2>
				<div class="article-date">08-04-2015</div>
		<p>Integrating Handlebars templates in modern web development workflow has been crucial in helping me organize my code neatly and maintain sanity. I want to achieve a few things:</p>
		<ul>
		<li>avoid the <code>&lt;script&gt;</code> tags to take advantage of syntax highlighting,</li>
		<li>break large templates into smaller files that can be managed and reused (componentized),</li>
		<li>automatically compiles and ready for use, and</li>
		<li>namespaced with file names as template names.</li>
		</ul>
		<p>In a current Backbone.js application at work, which is set up with <a href="gruntjs.com">grunt</a> and <a href="requirejs.org">RequireJS</a> (you can find a similar set up with the default <a href="https://github.com/yeoman/generator-backbone/">yeoman backbone generator</a>), I have found the following set up to meet most of these goals.</p>
		<p>I can use the templates with RequireJS in the views like so:</p>
		<pre><code class="language-javascript">// viewOne.js
		
		// I use commonjs syntax with require
		// http://requirejs.org/docs/whyamd.html#sugar
		var Templates = require('templates');
		var viewTemplate = Templates.viewOne;
		var html = viewTemplate({data: 'test'});
		</code></pre>
		<p>The template directories look something like this</p>
		<pre><code class="language-bash">app/templates/
		├── viewOne.hbs
		├── viewTwo.hbs
		├── viewThree.hbs
		├── ...
		└── viewTwentyThree.hbs
		
		0 directories, 23 files
		</code></pre>
		<p>I use <a href="https://github.com/gruntjs/grunt-contrib-handlebars"><code>grunt-contrib-handlebars</code></a> to compile the templates. Here&#8217;s the Gruntfile.js config for local development:</p>
		<pre><code class="language-javascript">handlebars: {
		    compile: {
		        options: {
		            amd: true,
		            namespace: 'Templates',
		            partialsUseNamespace: true,
		            processName: function(filePath) {
		                var file = filePath.replace(/.*/(w+).hbs/, '$1');
		                return file;
		            }
		        },
		        files:{
		            '.tmp/scripts/templates.js': ['&lt;%= yeoman.app %&gt;/templates/*.hbs']
		        }
		    }
		}
		</code></pre>
		<p>The above code does a few things. More detailed explanation of what each <code>options</code> does can be found on the plugin github page.</p>
		<ul>
		<li>The <code>processName</code> function takes the files and use their name as the template name.</li>
		<li>With <code>partialsUseNamespace</code> turned on, you can use partials both within your template as <code>&gt; partial</code> or through the global <code>Templates</code> object.</li>
		</ul>
		<p>In the build step for deployment, instead of just outputing the compiled templates into the <code>.tmp</code> folder, RequireJS can put Templates in the optimized javascript with the following Grunt task config (note the <code>paths</code> option):</p>
		<pre><code class="language-javascript">requirejs: {
		    dist: {
		        options: {
		            baseUrl: '&lt;%= yeoman.app %&gt;/scripts',
		            optimize: 'none',
		            paths: {
		                'templates': '../../.tmp/scripts/templates'
		            }
		        }
		    }
		}
		</code></pre>
		<p>This simple set up has allowed me to rapidly develop a complex apps by breaking down complex templates into small reusuable components and use them liberally anywhere with RequireJS, yet keep the built JavaScript minimal and compressed. I hope it will be useful for others who might be looking for a similar solution. If you find this useful or would like to suggest an improvement, please leave a comment.</p>
		
			</article><!-- .post-single -->
		
		<div class="nav-link">
				<a class="prev" href="/articles/2"><i class="icon-arrow-left"></i> Previous</a>
		</div>
		<footer class="main-footer">
			Built by Tri Nguyen using <a href="https://github.com/tnguyen14/tobiko">tobiko</a>. Copyrights ® 2015.
		</footer>

		<script type="text/javascript">
			var page = {
				env: "prod"
			}
		</script>

		<script type="text/javascript" src="/app.js"></script>
	</body>
</html>
